------------------
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
java -version
javac -version (прописать в переменную среды Path путь к папке bin jdk)

Установить: Sublime Text 2, либо Atom, Notepad++
Командная строка: https://git-scm.com/downloads, команды cd, ls

-----------------

1) Преобразование типа - преобразование значения одного типа в другое.
2) Неявное преобразование - выполняется от меньшего к большему автоматически. int -> double. Например: double y = 7;
3) Явное преобразование - преобразование между типами с потерей результата. Для того, чтобы программист всегда видел, что результат может быть потерян, необходимо записывать инструкцию преобразования явно:
double -> int необходимо: int x = (int)7.8;

------------------------------
Изучить: ASCII и UNICODE

ASCII - таблица символов, номер_символа = сам_символ
0..32 - управлящие символы, '\n' - символ перехода на новую строку, '\t' - символ табуляции
32 - 127 - символы английского алфавита
128 - 255 - все остальное

UNICODE - таблица символов, но каждый символ занимает 2 байта
------------------------------
Бема-Якоппини - что любой алгоритм можно выразить с помощью комбинации трех структур управления - линейная структура управления, условная структура управления, цикл.

Алгоритм - последовательность операций
1) Ввод
2) Вывод
3) Эффективность
4) Конечность
5) Детерминированность/однозначность

Задача: есть набор чисел A = {a1, a2, ..., an}

n -> бескон	ечность
an = -1

Посчитать сумму чисел. Посчитать сумму четных чисел.

TaskN
ДЗ на числа:
1) Клиент приходит в банк, и просит снять сумму определенную, надо вывести:
5000 - 
1000 - 
500 - 
100 - 
50 -
10 - 
5 - 
2 - 
1 -
2) Сумма цифр считанного числа
ДЗ на последовательности:
3) Посчитать сумму отрицательных чисел
4) Посчитать произведение положительных И сумму нечетных чисел
5) Посчитать произведение чисел, сумма цифр которых оканчивается на 7
6) Посчитать сумму чисел, порядок вхождения которых - четное число

Определение:
Массив - набор элементов фиксированного размера, каждый из которых доступен по индексу.
- грубо говоря: массив - набор пронумерованных переменных

ДЗ на массивы:
7) Сумма чисел массива
8) Сумма элементов, стоящих на нечетных позициях
9) Количество локальных максимумов a[i-1] <= a[i] > a[i+1]

ДЗ:
10) Степени двойки
11) ДОДЕЛАТЬ/СДЕЛАТЬ/ПЕРЕДЕЛАТЬ домашки
12) Пусть есть два массива символов text[], word[], длина word < длина text. Надо найти позицию, с которой word входит в text
char text[] = {'H', 'e, 'l', 'l', 'l', 'o'};
char word[] = {'l','l','o'};
result - 3
13) Попробовать реализовать через Кнута-Морриса-Пратта

-----------------------------------
Подпрограмма - программа внутри основной программы. Подпрограмма может быть многократно вызвана. У подпрограммы обязательно есть имя. Подпрограммы могут иметь формальные параметры. Подпрограммы делятся на две группы
	1. функции - подпрограммы, которые явно возвращают результат своего выполнения.
		y = f(x);
		f - название функции
		x - формальный параметр функции

		6 = f(7);
		7 - аргумент, подставляется в формальный параметр

		// объявление функции
		// int - тип возвращаемого значения
		// sum - название функции
		// int a, int b - формальные параметры
		// return - оператор возврата
		public static int sum(int a, int b) {
			int result = a + b;
			return result;
		}

	public static void main(String[] args) {
		int x = 7;
		int y = 8;
		//x, y - аргументы
		//sum(x,y) - вызов функции
		// x копируется в a, y копируется в b
		// результат их суммы будет вместо вызова
		int sumXY = sum(x, y);

		System.out.println(sumXY);
	}

	Если функции имеют одинаковые названия, но разные формальные параметры - они называются перегруженными.

ДЗ на функции:
14) Написать функции, которые ищут минимальный и максимальный элементы массива
15) Написать фукнцию, решающую квадратное уравнение. Она должна возвращать массив корней
	
	2. процедуры - это подпрограмма, которая явно не возвращает значения своего выполнения, но, обязательно обладает побочным эффектом

16) Написать процедуру, которая выводит минимальные числа в каждой строке
17) Написать процедуру, которая выводит минимальные числа в каждом столбце
18) Написать процедуру, котрая выводит максимальное число на побочной диагонали квадратной матрицы
19) попробовать написать оптимальный вариант фибонначи
-----------------------------------------------------------
Примитивные типы: int, char, boolean, double, byte, long, float, short (приведение типов - явное и неявное)
Ссылочные типы - массивы (они хранят ссылку на значение)
Базовые конструкции java - if, while, for
Подпрограммы (тип возвращаемого значения, return, формальные параметры и аргументы) - функции (непосредственно возвращают значения, процедуры - непосредственно значения не возвращают, тип возвращаемого значения - void). Подпрограммы в java - методы.
Массивы - выделение памяти (new), явная инициализация
Многомерные массивы.
Рекурсия - стек вызовов.
-----------------------------------------------------------
Объект - некоторая сущность, обладающая состоянием (свойства) и поведением (действия).
Маша
СОСТОЯНИЕ:
- пол: женский
- возраст: 24
- рост: 1 71
- вес: 49
- цвет волос: Рыжий
- цвет глаз: зеленый
- профессия: ведьма
ПОВЕДЕНИЕ:
- наколдавать()
- приворожить()
Класс - абстрактный тип данных (ссылочный), (описывается методом абстракции - выделение значимых характеристик в контексте решаемой задачи). Класс описывает возможные состояния и поведения объекта.
Объект - экземпляр класса.
-------------------------------
Класс - отдельный файл (обычно), файл и класс имеют (обязательно) ОДНО НАЗВАНИЕ.

Human marsel; - объявление объектной переменной (переменная, указывающая на объект, изначально - null).
marsel = new Human(); - создание объекта, теперь marsel указывает на объект.
Поля (члены класса) - переменные внутри класса. Конкретные значения полей задают состояние объекта.

Инстантивация - создание объекта (instance), оператор new.   
Инициализация - задание начального состояния объекта.

Конструктор (не является членом класса) - набор инструкций внутри класса, которые говорят, как именно нужно инициализировать объект. По виду конструктор очень сильно похож на метод, имеет название(такое же, как и класс, может иметь формальные параметры, но не имеет типа возвращаемого значения, и не является методом вообще).

В джава по умолчанию для каждого класса автоматически создается пустой конструктор (конструктор по умолчанию).
Переопределение конструктора - написание своего конструктора с нужными действиями инициализации.
Если вы определили свой конструктор с параметрами, то конструктора по умолчанию больше нет.

Класс - поля, конструктор (чтобы отдельно не писать инструкции по заданию начального состояния.)

Метод(член класса) - подпрограмма внутри класса. Описывает поведение объекта. Вызывается непосредственно из созданного объекта.

Парадигма программирования - стиль организации вычислений внутри программы + стиль мышления программиста.

Парадигма процедурного программирования:
программа = алгоритм + структура данных (С, Pacsal, Basic)
+ хорошая ориентация на алгоритмы
+ большое внимание уделяется оптимизации структур данных
- спагетти код (функция вызывает функцию, которая вызывает функцию)
- описать сущности конкретные достаточно трудно
- незащищенность данных

Парадигма логического программирования:
программа = логические придикаты (функции принимающие значение истина и ложь - язык Prolog)

Парадигма функционального программирования:
программа = функция

Парадигма объектно-ориентированного программирования:
программа = объекты, посылающие друг другу сообщения

Четыре кита ООП
1) Абстракция
2) Инкапсуляция 
	2.1 Совмещение алгоритмов и структур данных в одной сущности-капсуле - объект.
	2.2 Возможность обеспечения защиты внутреннй структуры данных
3) Наследование
4) Полиморфизм

Задача - посчитать количество людей определенных возрастов (решили на паре).

Уровень доступа - публичный, приватный, защищенный, публичный в пакете
Модификатор доступа - public, private, protected, (не указывается)

Метод доступа - вспомогательный метод, который позволяет контролируемо работать с защищенными данными

ИТОГО:

Класс состоит из:
1) Приватных (private) полей
2) Конструкторов (пустого и с формальными параметрами)
3) Методы 
4) Методы доступа - getters/setters (getИмяПоля, setИмяПоля)

20) Сортировать людей по возрасту используя ООП (методом пузырька) - задать массив из 15 человек.

---------------------------------------------
Статические члены класса и статические инициализаторы.

Статическое поле (с модификатором static) - глобально для всех объектов.

ДЗ ДОПОЛНИТЕЛНО - все по static (поля, инициализаторы)

СОВЕТЫ:

1) Создавать неизменяемые объекты.Начальное состояние передавать в конструкторе, там выполнять все проверки, а доступ к изменению - не давать. (поля закрыты, сеттеров нет)
ДЗ:
21) Добавить в ArrayList - removeLast, removeFirst, removeByIndex(int index), remove(int element)

Список (List) - абстрактный тип данных, представляющий собой хранилище элементов более высокого уровня, нежели массив с операциями - добавить, удалить, найти и т.д.
ArrayList - реализация списка на основе массива.

Стэк - список, поддерживающий работу только с последним добавленным элементом (принцип LastInputFirstOutput - последним вошел, первым вышел);
- положить наверх (push)
- взять сверху (pop)
ДЗ: проверка последовательности скобок

Очередь и Граф разобрать.

Очередь - список, поддерживающий взятие последнего и добавление первого.
- положить в начало (enqueue)
- взять с конца (dequeue)

Граф - множество вершин и множество ребер.
- Добавить вершину (не у нас)
- Добавить ребро
- Найти количество соседей вершины
- Найти вершину с максимальным количеством соседей
- Получить массив всех соседей
- Проверить, есть ли ребро между вершинами

22) Стек и очередь на основе связных списков
LinkedStack
LinkedQueue
23) Пофиксить remove + сделать метод reverse в LinkedList
24) Карманная сортировка по году

Наследование - механизм ООП, позволяющий объектам класса потомка,
копировать и переопределять состояние и поведение объектов класса предка.
Чтобы наследование было адекватным, важно принименять правило -
все объекты потомка, являются предком.
При наследовании конструктор не наследуется. (конструктор не является членом класса)
Переопределение методов - запись новой реализации метода в классе потомке с той
же сигнатурой что и в предке.
protected - модификатор доступа, который позволяет классу потомку получить
доступ к членам класса предка.
Если метод в потомке не переопределен, то вызывается метод предка.

ПОЧИТАТЬ: UML, SOLID

Полиморфизм - механизм ООП, позволяющий работать с объектами разных типов
таким образом, будто они принадлежат одному типу.

Восходящее преобразование - смена типа объектной переменной с типа класса потомка
на тип класса предка. (неявное преобразование).

Абстрактный класс - класс, экземпляры которого
создавать нельзя. Используется модификатор abstract
Абстрактный метод - метод без реализации.

--------
ДЗ 25:
Создать класс ParkingPlace
Внутри массив типа Transport (абстрактный класс)
Методы ParkingPlace
- припарковатьМашину
- убратьМашину

Transport
- уехать()
- приехать()
- госномер
Несколько видов транспорта
--------------------
1) В Java множественное наследование запрещено
2) Зачем мне классы, в которых есть только методы?

Интерфейс - фактически это
полностью абстрактный класс без полей
Семантически - интерфейс это инкапсуляция поведения
Интерфейс говорит, какое поведение
должно быть у классов, которые его имплементируют
Между собой интерфейсы наследуются

ДЗ: тоер.
1) Классы и объекты + объектные переменные
2) Члены класса + конструкторы
3) Статические члены класса
4) Статические инициализаторы
5) Инкаспуляция и методы доступа
6) Наследование + восходящее преобразование
7) Интерфейсы, полиморфизм, абстрактные классы
8) Класс Object, методы - equals и toString
9) String, что значит final класс, equals, StringPool, intern

26) Описать класс MyString и реализовать Comparable
сравнение в лексикографическом порядке.
гуглить: лексикографический порядок
НЕ ГУГЛИТЬ И НЕ СМОТРЕТЬ - Java Comparable и класс String
27) Реализовать бинарный поиск в упроядоченном массиве
public static <V> V binarySearch(V[] objects, Comparator<V> comparator)
public static <V> V binarySearch(Comparable<V> objects[]);

Обобщения - дженерики - подстановочные типы

try - помечаем блок кода, где возможна исключительная ситуация
catch - указываем тип возможной ошибки, ее объект и инструкции по ее разрешению

ArithmeticException - ошибка арифмитичского выражения
StackOverflow - переполнение стека вызовов
FileNotFoundException - не найден файл

Error - системные ошибки
VirtualMachineError - потомок Error
StackOverflowError - потомок VirtualMachineError
OutOfMemory - потомок VirtualMachineError

RuntimeException - непроверяемые исключения
К непроверяемым исключениям также относят Error

ArithmethicException - непроверяемое, потомок RuntimeException
IllegalArgumentException - непроверяемое, потомок RuntimeException
Exception - проверяемые исключения
FileNotFoundException - проверяемое, потомок Exception

Проверяемое исключение вы ОБЯЗАНЫ ОБРАБОТАТЬ try-catch
Если метод генерирует проверяемое исключение, вы обязаны поставить throws
throw new - выброс исключение
throws - вы говорите, что метод может быть источником проверяемого исключения

1) Структуры управления
2) Типы данных в Java
3) Массивы
4) Классы и объекты
5) Инкапсуляиция
6) Члены класса
7) Статические члены класса
8) Инициализаторы
9) Наследование - абстрактные классы
10) Полиморфизм - интерфейсы
11) Класс Object
12) Класс String
13) Comparable + Compare
14) Обобщения
15) Исключения
16) Обобщенный ArrayList

27) Обобщенный LinkedList

-------------
Java IO - набор классов для работы с вводом
и выводом, пакет java.io
http://www.novsu.ru/file/3619

В основе набора класса лежат четыре класса:
Stream - последовательность байтов
Изначально доступны три базовых потока:
System.in
System.err
System.out

InputStream
    int read() - считать байт из потока
    int read(byte b[]) - считывает байты в массив b, количество считанных байт возвращает как результат
OutputStream
    write(int b)  - записывает байт в поток
    write(byte b[]) - записывает массив байтов в поток

FileInputStream/FileOutputStream - реализация потоков на файлах
ByteArrayInputStream/ByteArrayOutputStream - потоки над массиво байтов
ObjectInputStream/ObjectOutputStream - для сериализации
BufferedInputStream/BufferedOutputStream
Reader
Writer
-----------------------------------------
Паттерн - классическое решение какой-либо общей проблемы.

Паттерн проектирования DAO - Data Access Object
Проблема: сильная зависимость логики приложения от
хранилища данных.
Решение: прослойка-интерфейс, предоставляющая набор операций
для работы с данными + конкретные реализации под конкретное хранилище

28) 1) Дома: заменить User[] на ArrayList<T>
    2) Есть проблема - вызывав findAll один раз, второй раз его не вызовишь.
    Решить эту проблему

Пусть имеется обобщенный тип A<T>, тогда:
Если объявили, A<Animal>
То A<Animal> это потомок "сырого типа" A.
Но, A<Herbivore> не является потомком A<Animal>, несмотря
на то, что Herbivore потомок Animal

1) Если объявили List<A>, и при этом C - потомок A, и B - потомок A
List<C> и List<B> - потомки List, но не потомки List<A>.
При этом - List<? extends A> - предок для List<C> и List<B>, но при этом
класть туда ничего нельзя, только получить, причем тип A.
Пусть D - потомок C.
Значит объекты типа D могут хранить списки типа List<A>, List<C>,
List<D>. Их всех можно преобразовать к типу List<? super D> и класть
туда данные, но только типа D. Вытащить нельзя.

https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html
https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html

Рефлексия - самотображение. Механизм, позволяющий манипулировать
классами как объектами.

- создавать объект класса, не зная самого класса
- получение полей класса
- получение конструктора класса
- получение методов класса
- возможность изменять значения полей и вызывать
методы над объектами

------------------------------
IO

InputStream - абстрактный класс, предназначенный для работы с входным потоком (последовательностью байт)

Имеет методы:
int read() - считывает следующий байт из входного потока и возвращает число в диапазоне 0..255, которое соответствует коду символа
возвращает -1 если считать нельзя
int read(byte b[]) - считывание массива байтов в массив байтов из входного потока
Функция возвращает количество считанных байтов
OutputStream - класс для записи данных в поток
write(int b) - записывает в поток один байт информации
write(byte b[]) - записывает в поток массив байтов
------—
Reader и Writer - классы, работающие не с потоком байтов, а с потоком символов
BufferedReader - реализация Reader'a, использующая буфферизацию
-------------------------------
ЗАДАЧА:
Реализовать модуль хранения данных - людей
Класс IdGenerator - отвечает
за генерацию уникального id,
работает через инкремент
Последний id хранит в файле

BufferedWriter - класс, обеспечивающий работу
с потоком через буффер (данные буфферизируются для
более быстрой работы), потомок Writer - работает
с char вместо byte.
BufferedWriter принимает в качестве параметра конструктора
другой Writer, например FileWriter
FileWriter потомок OutputStreamWriter-а. Таким образом
FileWriter работает с потоком файлов.

ЕЩЕ РАЗ:
Writer - работает с символами
1) потомок BufferedWriter - работает с буффером
2) потомок OutputStreamWriter - работает с потоком
  2.1) потомок FileWriter - работает с потоком файловым
В BufferedWriter можно передать другой Writer для буфферизации

ДЗ:
В DataStorage - доделать update.
Сделать AutoDataStorage - find, findAll, save, update, delete
Auto
- id
- модель
- цвет
- пробег
autos.txt

В DataStorage - тесты для UsersDataStorage
МОДУЛЬНОЕ ТЕСТИРОВАНИЕ
- тестирование отдельных модулей (классов) независимо друг от друга
- тестируются открытые методы
- два понятия - expected - ожидаемый результат, actual - реальный результат
Если метод работает корректно, то его expected совпадает с actual
- Фреймворк (набор библиотек для модульного тестирования) - JUnit

-----------------------------------------------------
ДЗ
1) ПОЛНОСТЬЮ ДОДЕЛАТЬ ArrayList
2) ПОЛНОСТЬЮ ДОДЕЛАТЬ LinkedList
4) Добавить Iterator в ArrayList + в Main проверить
3) Суметь пояснить за каждую строчку кода

Самописное:
List
ArrayList - список на основе массива
LinkedList - список на основе связного списка
Встроенное:
Iterable
 - iterator()
Iterator
 - next()
 - hasNext()


Java Collections
В основе два интерфейса:
Collection<E> (расширяет Iterable) и Map<K, V> (не расширяет Iterable)
Рекомендация и подход:
смотреть исходный код
и разобраться в нем +
смотреть статьи

Потомки Collection - просто набор элементов
 - List<E>, подразумевает, что есть индексы
    - get
    - set
    - indexOf и др.
 - Queue<E> - очередь
    - add - добавляет, если очередь не может принять элемент - выбрасывает исключение
    - offer - добавляет, если очередь не может принять элемент (допустим, не хвататает размерности, возвращает - false)
    - poll - возвращает голову очереди с последующим удалением
    - peek - как poll, только без удаления
 - Deque<E> - двусторонняя очередь (стек + очередь)
 - AbstractCollection - предлагает реализации методов Collection
  (см. contains)

  ------------------------
  Как работает метод add в ArrayList
        - обеспечить емкость для size + 1 = ensureCapacityInternal
        - добавить
        вернуть true
  Как работает метод ensureCapacityInternal в ArrayList
        - проверяем, если данных нет, то размер нужно выделить какой? - максимальный между "по-умолчанию", и между "требуется"
        - выделяем размер - ensureExplicitCapacity

  Как работает метод ensureExplicitCapacity в ArrayList
        - проверяем, если надо выделить размер - выделяем grow(minCapacity)

  Как работает метод grow в ArrayList
        - вычиляем новый размер - старый + половинка старого
        - создали копию массива с новым размером с помощью System.arraycopy - нативная.

  -------------------------------

    Наблюдатель - поведенческий паттерн проектирования.
     Решает проблему обработки событий. Наблюдатели и наблюдаемый. Если в наблюдаемом
     объекте произошло событие, он оповещает своих наблюдателей.

  --------------------------------

  Когда в классе A необходим функционал класса B, есть следующие варианты:
  1) Худщий - A наследник B, минусы - если в B появится какой-либо метод, он автоматически
  становится доступен из объекта класса A. А нам это не всегда нужно. + Кривая архитектуры системы
  2) Агрегирование с сильной связью:
    В классе A есть поле типа класса B. Минусы - а что, если нам хочется заменить класс B другой реализацией.
  3) Аргерирование с слабой связью:
    Создается интерфейс C, класс B, D и т.д. реализуют данный интерфейс. В классе A определяется поле типа C.


  Любой проект на JAVA:
  1) Кодинг
  2) Компиляция - javac
  3) Сборка - jar-файл
  4) Запуск - java-машина
  Задача: минимизировать необходимость перекомпиляции и пересборки

  ДОДЕЛАННЫЙ DATASTORAGE - Auto и Humans

  DaoFactory - getDao(Class<T> daoClass)
  Properties file
  humans.file.name
  auto.file.name
  humans.dao.class
  auto.dao.class

  Map - словарь, карта, ассоциативный массив
  Хранит пары ключ-значения
  Map - встроенный интерфейс в Java
  Содержит методы put и get.
  Реализован классом HashMap
  HashMap - массив узлов (связных списков)
  Когда приходит на вход значение (вызывается метод put(K key, V value)
  Происходит следующее:
  1) вызывается метод hash над ключом:
  static final int hash(Object key) {
          int h;
          if (key == null ) {
            return 0;
          } else {
            h = key.hashCode() ^ (h >>> 16));
          }
      }
  ----------------------------------
  Цель - преобразовать ключ в число - это число и есть индекс корзины в HashMap


DAO - DataAccessObject - объект доступа к данным.
Пара: Интерфейс + Реализация

DAO - это всегда CRUD-методы
Create
Read
Update
Delete

ДЗ ТОЛЬКО:
РЕАЛИЗОВАТЬ AutoDaoFileBasedImpl
- find, findAll, findByUsed, save
Разобрать FileDaoQueryUtils

--------------------------------------------------------
Задача:
Пусть имеется n-размерный массив.
Его элементы имеют индексы [0..n-1]
К нам пришла пара Key,Value.
Нужно определить, под каким индексом мы положим Value в массив,
так, чтобы потом быстро достать.
1) Берем у Key хеш-код
2) Так как хеш-код может быть большим, гораздо бОльшим
чем n, мы должны хеш-код урезать.
Отбрасываем все биты, которые не вмещаются в n:
hashCode & (n - 1) - получили позицию в массиве.
Проблемы:
а) Если размер массива не степень двойки, маска будет
плохой, например 10000, тогда позиции всегда будут только 2 числа.
Если же размер массива - степень двойки, маска будет иметь
вид 1111..111 - это лучше, позволит избежать коллизий,
то есть когда одна позиция соответсвует двум ключам.
б) Если хеш-код кривой, и два ключа отличаются
только старшими битами, тогда будет много коллизий.
Вариант решения - сделать сдвиг старших битов на младшие.
hashCode >>> 16, сдвиг левых 16 бит на позиции младших 16-ти бит.
В итоге получим нормальные хеш-коды.
НО! Что делать, если хеш-код был норм?
ПРименить xor, для нормальных хешкодов профит в том
что сдвиг не сильно повлиял, наоборот теперь учитывается
влияние старших битов.
А на плохие хеш-коды xor не даст эффекта.


-----------------------------------------

DZ - изучить проект DataStorage
Составить список вопросов
Доделать AutoDao с использованием FileDaoQueryTemplate
ВАШ ПРОЕКТ - КОПИЯ МОЕГО

-----------------------------------------

Set - это множество элементов. Каждый элемент уникален.
Как Set гарантирует уникальность значений, которые в него входят???
Вспомнить Map
Map гарантирует уникальность ключей за счет
сравнения по hashCode и, если хеши совпали по equals
Так вот HashSet использует в качесте контейнера HashMap.
ТОлько значения HashSeta являются ключами HashMap

1) Изучить интерфейс Map
2) Еще раз попробовать посмотреть HashMap (как работает putVal без деревьев)
3) Изучить интерфейс Set
4) Изучить класс HashSet

---------------------
// Первичный ключ - уникальный идентификатор строки
// Внешний ключ - ссылка на уникальный идентификатор
// строки из другой таблицы
// group_user.id - первичный ключ
// auto.owner_id - внешний ключ
// group_user - родительская таблица
// auto - дочерняя
// их соотношение реляционным

ДЗ:
Адекватно заполнить пользователей и машины
Попробовать реализовать DAO на БД
изучать SQL

ДЗ:
AutoDao на файлах доделать
AutoDao на JDBC доделать
UsersDao на JDBC доделать
